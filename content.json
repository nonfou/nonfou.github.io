{"meta":{"title":"徐冲的草稿本","subtitle":"","description":"","author":"Chong Xu","url":"http://nonfou.github.io","root":"/"},"pages":[{"title":"tag","date":"2022-05-24T13:37:22.000Z","updated":"2022-05-24T13:38:24.198Z","comments":true,"path":"tag/index.html","permalink":"http://nonfou.github.io/tag/index.html","excerpt":"","text":""},{"title":"about","date":"2022-05-24T13:43:28.000Z","updated":"2022-05-24T13:44:14.549Z","comments":true,"path":"about/index.html","permalink":"http://nonfou.github.io/about/index.html","excerpt":"","text":"where there is a will, there is a way."},{"title":"category","date":"2022-05-24T13:38:36.000Z","updated":"2022-05-24T13:38:54.217Z","comments":true,"path":"category/index.html","permalink":"http://nonfou.github.io/category/index.html","excerpt":"","text":""}],"posts":[{"title":"grub乱码","slug":"grub乱码","date":"2022-07-12T13:37:36.000Z","updated":"2022-07-12T13:51:27.074Z","comments":true,"path":"2022/07/12/grub乱码/","link":"","permalink":"http://nonfou.github.io/2022/07/12/grub%E4%B9%B1%E7%A0%81/","excerpt":"","text":"问题LMDE grub启动的时候出现乱码 解决 查看grub下的字体 12ls /boot/grub/fonts/ 修改unicode字体1vim /etc/default/grub.d/60_mint-theme.cfg","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://nonfou.github.io/tags/Linux/"}]},{"title":"CentOS7安装Oracle19c","slug":"CentOS7安装Oracle19c","date":"2022-07-08T12:42:33.000Z","updated":"2022-07-12T13:48:01.460Z","comments":true,"path":"2022/07/08/CentOS7安装Oracle19c/","link":"","permalink":"http://nonfou.github.io/2022/07/08/CentOS7%E5%AE%89%E8%A3%85Oracle19c/","excerpt":"","text":"Oracle安装关闭selinux, 设置 SELINUX&#x3D;disabled 1vim /etc/selinux/config 关闭防火墙 123systemctl stop firewalldsystemctl disable firewalld 创建用户和组 123456789groupadd oinstallgroupadd dbagroupadd operuseradd -g oinstall -G dba,oper oracle 设置密码 12345passwd oracleexit 上传安装包到 /home/oracle/ 创建安装文件夹 12mkdir -p /home/oracle/appmkdir -p /home/oracle/app/oracle/product/19.3/dbhome_1 解压 12unzip /home/oracle/LINUX.X64_193000_db_home.zip -d /home/oracle/app/oracle/product/19.3/dbhome_1 授权 1234chown -R oracle:oinstall /home/oracle/appchmod 755 -R /home/oracle/app 环境变量 12345678910111213141516171819202122su - oraclevim /home/oracle/.bash_profile# 加入以下内容export ORACLE_BASE=/home/oracle/app/oracleexport ORACLE_HOME=/home/oracle/app/oracle/product/19.3/dbhome_1export ORACLE_SID=orclexport ORACLE_TERM=xtermexport PATH=$ORACLE_HOME/bin:/usr/sbin:$PATHexport LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/libexport NLS_LANG=AMERICAN_AMERICA.AL32UTF8export ORACLE_UNQNAME=$ORACLE_SIDexport PATH# 加入以上内容source /home/oracle/.bash_profileexit VNC安装查看组列表 1yum grouplist 安装桌面环境 根据组列表返回的名称安装 操作系统为中文1yum groupinstall -y &quot;GNOME 桌面&quot; 操作系统为英文1yum groupinstall -y &quot;GNOME Desktop&quot; 安装VNC服务软件 1yum install tigervnc-server -y 验证是否安装成功 1rpm -qa | grep tigervnc-server 创建VNC服务 1cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service 修改启动用户 1vim /etc/systemd/system/vncserver@\\:1.service 将 &lt;USER&gt; 更改为 oracle 设置密码 12345su - oraclevncpasswdexit 启动服务 123systemctl restart vncserver@\\:1.servicesystemctl daemon-reload 查看端口是否监听 1netstat -lnpt|grep Xvnc VNC连接或登录桌面环境VNC下载地址 VNC访问 $&#123;oracle服务器ip&#125;:1 密码为运行vncpasswd命令时设置的密码 安装123456su - oraclecd /home/oracle/app/oracle/product/19.3/dbhome_1./runInstaller 问题增加交换空间 123456789101112131415161718# 创建文件 6Gdd if=/dev/zero of=swapfree bs=1M count=6144# 将此文件作为交换空间mkswap swapfree# 开启交换空间swapon swapfree# 写入 `/etc/fstab` 交换空间开机启动vim /etc/fstab## 加入以下内容/home/oracle/swapfree swap swap defaults 0 0## 加入以上内容","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://nonfou.github.io/tags/Linux/"},{"name":"Oracle","slug":"Oracle","permalink":"http://nonfou.github.io/tags/Oracle/"}]},{"title":"Mock后端接口","slug":"Mock后端接口","date":"2022-07-07T15:01:52.000Z","updated":"2022-07-12T13:48:40.292Z","comments":true,"path":"2022/07/07/Mock后端接口/","link":"","permalink":"http://nonfou.github.io/2022/07/07/Mock%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"场景后端对于接口数据的Mock 依赖的子服务 Feign&#x2F;Dubbo等rpc请求 第三方接口,天眼查&#x2F;启信宝 方案参考两个开源项目实现 模拟mock.js生成数据，简称 项目1 基于Agent实现接口mock，简称 项目2 项目1可以对mock数据有很好的支持，项目2基于Agent，无侵入的完成接口的代理。由此对两个项目进行了整合。 实践 代理的方法针对你想Mock的所有接口，找寻一个共有的前置方法。 Dubbo调用 org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke Feign 调用 feign.SynchronousMethodHandler.invoke 匹配Mock规则 项目2中是通过以类名称#方法名称作为名称，以文件的形式去定义Mock的内容。 为了结合项目1去使用，我们在原有Mock内容的基础上增加了Mock类的路径 1234&#123; &quot;f_mock_data&quot;: &quot;&quot;, &quot;class_name&quot;: &quot;com.nonfou.example.dto.BasicInfoDTO&quot;&#125; 然后使用项目1mock出不同的数据。 1new AnnotationMockContext().mock(Class.forName(&quot;$&#123;类路径&#125;&quot;)); 难点 思路的打通 理解使用Agent，明白项目2设计思路，如何结合项目1使用。 找到代理方法 针对我想Mock的接口，通过给所有要代理的接口添加了注解，然后使用Aop去增强，这样所有的接口都会经过Aop的代理方法。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://nonfou.github.io/tags/Java/"},{"name":"Mock","slug":"Mock","permalink":"http://nonfou.github.io/tags/Mock/"}]},{"title":"beanFactory#getBean(Class)顺序定义","slug":"beanFactory-getBean-Class-顺序定义","date":"2022-01-05T22:06:38.000Z","updated":"2022-07-12T13:47:50.051Z","comments":true,"path":"2022/01/06/beanFactory-getBean-Class-顺序定义/","link":"","permalink":"http://nonfou.github.io/2022/01/06/beanFactory-getBean-Class-%E9%A1%BA%E5%BA%8F%E5%AE%9A%E4%B9%89/","excerpt":"","text":"Spring中获取ApplicationContext的一种方法 123456789@Componentpublic class ApplicationContext implements ApplicationContextAware&#123; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; SpringFactory.setApplicationContext(applicationContext); &#125;&#125; 12345678910111213public class SpringFactory &#123; private static ApplicationContext applicationContext; public static setApplicationContext(ApplicationContext applicationContext) &#123; this.applicationContext = applicationContext; &#125; public statitc &lt;T&gt; T getBean(Class&lt;T&gt; cla) &#123; return applicationContext.getBean(cla); &#125;&#125; 场景现有一接口定义如下 12345678910package com.b.a.c;@Servicepublic class DefaultUserServiceImpl implements UserService &#123; @Override public String getUserName() &#123; return &quot;Tom&quot;; &#125;&#125; 当我想获取 UserService 的实现类时，通过 SpringFactory.getBean(UserService.class)获取到 DefaultUserServiceImpl 对象, 输出 Tom 再添加一个实现 12345678910package com.b.a.c;@Servicepublic class AllUserServiceImpl implements UserService &#123; @Override public String getUserName() &#123; return &quot;Tom-all&quot;; &#125;&#125; 当我想获取 UserService 的实现类时,通过 SpringFactory.getBean(UserService.class).getUserName()获取到 AllUserServiceImpl 对象, 输出 Tom-all 以上是通过idea等工具直接编译运行的方式 现再添加一个实现, 此类是通过jar包来引入 12345678910package com.a.b.a;@Servicepublic class JarUserServiceImpl implements UserService &#123; @Override public String getUserName() &#123; return &quot;Tom-jar&quot;; &#125;&#125; 通过idea直接编译运行 SpringFactory.getBean(UserService.class).getUserName() ，输出 Tom-all; 通过打包成jar包的方式运行 java -jar xxx.jar的方式运行 SpringFactory.getBean(UserService.class).getUserName()，输出 Tom-jar; 问题当一个接口注入了多个实现类时，applicationContext.getBean(Class aClass)获取到的bean是哪个？应该是默认获取第一个实现类；如何定义，才能让某一个实现类总是优先被获取？ 思考applicationContext.getBean(Class aclass) 获取到的bean，与bean被扫描到的先后顺序有关系。 当通过idea等工具直接运行程序时，当前的工作目录会优先比引用的jar包先扫描到，而排名靠前的文件夹&#x2F;类也是优先被扫描(com.b.a.c.AllUserServiceImpl 先比 com.b.a.c.DefaultUserServiceImpl)被扫描到，依次放到 {@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNames} 当通过jar包的方式运行时，会按照jar包先后顺序进行扫描注入bean放到{@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNames} 需求不管是jar包运行，还是本地编译运行，通过 SpringFactory.getBean(UserService.class) ，我想获取到的实现类都应该是 DefaultUserServiceImpl 对象 解决可以通过 自定义实现 {@link BeanDefinitionRegistryPostProcessor} 进行处理 {@link BeanDefinitionRegistryPostProcessor} 是 BeanFactory的后置处理器，当所有bean 被处理完成后，会调用该接口的实现类对应的方法 我们需要在此实现类中改变 {@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNames} 中 bean的顺序 从而 改变 applicationContext.getBean(Class) 获取到的实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231import cn.hutool.core.collection.CollUtil;import cn.hutool.core.util.StrUtil;import com.google.common.collect.Lists;import com.sinitek.sirm.org.service.IOrgService;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Objects;import org.apache.commons.lang3.builder.EqualsBuilder;import org.apache.commons.lang3.builder.HashCodeBuilder;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;import org.springframework.context.annotation.Configuration;import org.springframework.core.annotation.Order;import org.springframework.lang.NonNull;/** * 对&#123;@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNames&#125; * 进行排序 * &lt;p&gt; * 借助&#123;@link Order&#125; 注解, 同一个基类中，value 值越小，位置越靠前。 * &lt;/p&gt; * * @author chong.xu * @version 2021-1122 * @since v3.5.0.x */@Configurationpublic class BeanDefinitionRegistryOrder implements BeanDefinitionRegistryPostProcessor &#123; private static final Logger log = LoggerFactory.getLogger(BeanDefinitionRegistryOrder.class); /** * 定义要排序的bean的基类 */ private static final List&lt;Class&lt;?&gt;&gt; orderClassList = Collections.singletonList( UserService.class); @Override public void postProcessBeanDefinitionRegistry( @NonNull BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException &#123; List&lt;BeanDefinitionNameOrder&gt; beanList = extractBeanDefinitionOrder(beanDefinitionRegistry); Map&lt;Class&lt;?&gt;, List&lt;BeanDefinitionNameOrder&gt;&gt; beanDefinitionMap = groupByClass(beanList); beanDefinitionMap.forEach((key, definitionList) -&gt; &#123; if (CollUtil.isNotEmpty(definitionList)) &#123; Collections.sort(definitionList); for (BeanDefinitionNameOrder beanDefinitionNameOrder : definitionList) &#123; String name = beanDefinitionNameOrder.getBeanDefinitionName(); BeanDefinition beanDefinition = beanDefinitionNameOrder.getBeanDefinition(); beanDefinitionRegistry.removeBeanDefinition(name); beanDefinitionRegistry.registerBeanDefinition(name, beanDefinition); &#125; &#125; &#125;); &#125; /** * 根据class类型分组 * * @param beanDefinitionNameOrderList bean定义列表 * @return [class, List] */ private Map&lt;Class&lt;?&gt;, List&lt;BeanDefinitionNameOrder&gt;&gt; groupByClass( List&lt;BeanDefinitionNameOrder&gt; beanDefinitionNameOrderList) &#123; if (CollUtil.isEmpty(beanDefinitionNameOrderList) || CollUtil.isEmpty(orderClassList)) &#123; return Collections.emptyMap(); &#125; Map&lt;Class&lt;?&gt;, List&lt;BeanDefinitionNameOrder&gt;&gt; result = new HashMap&lt;&gt;(); for (BeanDefinitionNameOrder beanDefinitionNameOrder : beanDefinitionNameOrderList) &#123; put(result, beanDefinitionNameOrder.getClassType(), beanDefinitionNameOrder); &#125; return result; &#125; private void put(Map&lt;Class&lt;?&gt;, List&lt;BeanDefinitionNameOrder&gt;&gt; map, Class&lt;?&gt; key, BeanDefinitionNameOrder value) &#123; List&lt;BeanDefinitionNameOrder&gt; beanDefinitionNameOrderList = map.get(key); if (CollUtil.isEmpty(beanDefinitionNameOrderList)) &#123; map.put(key, Lists.newArrayList(value)); &#125; else &#123; beanDefinitionNameOrderList.add(value); &#125; &#125; /** * 根据bean定义的名称列表返回 &#123;@link BeanDefinitionNameOrder&#125;列表 * * @param beanDefinitionRegistry &#123;@link BeanDefinitionRegistry&#125; * @return bean定义列表 */ private List&lt;BeanDefinitionNameOrder&gt; extractBeanDefinitionOrder( BeanDefinitionRegistry beanDefinitionRegistry) &#123; String[] beanDefinitionNames = beanDefinitionRegistry.getBeanDefinitionNames(); List&lt;BeanDefinitionNameOrder&gt; result = new ArrayList&lt;&gt;(); for (String beanDefinitionName : beanDefinitionNames) &#123; BeanDefinition beanDefinition = beanDefinitionRegistry.getBeanDefinition(beanDefinitionName); String className = beanDefinition.getBeanClassName(); Class&lt;?&gt; aClass = findClassForName(className); if (Objects.nonNull(aClass)) &#123; for (Class&lt;?&gt; matchClass : orderClassList) &#123; if (matchClass.isAssignableFrom(aClass)) &#123; Order order = aClass.getAnnotation(Order.class); int orderNumber = Objects.isNull(order) ? Integer.MAX_VALUE : order.value(); BeanDefinitionNameOrder beanDefinitionNameOrder = new BeanDefinitionNameOrder(); beanDefinitionNameOrder.setBeanDefinition(beanDefinition); beanDefinitionNameOrder.setBeanDefinitionName(beanDefinitionName); beanDefinitionNameOrder.setOrder(orderNumber); beanDefinitionNameOrder.setClassType(matchClass); result.add(beanDefinitionNameOrder); &#125; &#125; &#125; &#125; return result; &#125; private Class&lt;?&gt; findClassForName(String className) &#123; if (StrUtil.isEmpty(className)) &#123; return null; &#125; try &#123; return Class.forName(className); &#125; catch (ClassNotFoundException e) &#123; log.error(&quot;找不到该class文件:&#123;&#125;&quot;, className); return null; &#125; &#125; @Override public void postProcessBeanFactory(@NonNull ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException &#123; // nothing &#125; /** * 用于给 &#123;@link org.springframework.beans.factory.support.DefaultListableBeanFactory&#125;中的beanDefinitionNames进行排序的数据结构 */ static class BeanDefinitionNameOrder implements Comparable&lt;BeanDefinitionNameOrder&gt; &#123; private Integer order; private BeanDefinition beanDefinition; private String beanDefinitionName; private Class&lt;?&gt; classType; public Class&lt;?&gt; getClassType() &#123; return classType; &#125; public void setClassType(Class&lt;?&gt; classType) &#123; this.classType = classType; &#125; public Integer getOrder() &#123; return order; &#125; public void setOrder(Integer order) &#123; this.order = order; &#125; public BeanDefinition getBeanDefinition() &#123; return beanDefinition; &#125; public void setBeanDefinition(BeanDefinition beanDefinition) &#123; this.beanDefinition = beanDefinition; &#125; public String getBeanDefinitionName() &#123; return beanDefinitionName; &#125; public void setBeanDefinitionName(String beanDefinitionName) &#123; this.beanDefinitionName = beanDefinitionName; &#125; @Override public int compareTo(BeanDefinitionNameOrder o) &#123; return this.order - o.getOrder(); &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; BeanDefinitionNameOrder that = (BeanDefinitionNameOrder) o; return new EqualsBuilder().append(order, that.order) .append(beanDefinition, that.beanDefinition) .append(beanDefinitionName, that.beanDefinitionName).append(classType, that.classType) .isEquals(); &#125; @Override public int hashCode() &#123; return new HashCodeBuilder(17, 37).append(order).append(beanDefinition) .append(beanDefinitionName) .append(classType).toHashCode(); &#125; &#125;&#125; 此时在两个实现类中分别加上@Order注解 1234567891011package com.b.a.c;@Order(1)@Servicepublic class DefaultUserServiceImpl implements UserService &#123; @Override public String getUserName() &#123; return &quot;Tom&quot;; &#125;&#125; 1234567891011package com.b.a.c;@Order(2)@Servicepublic class AllUserServiceImpl implements UserService &#123; @Override public String getUserName() &#123; return &quot;Tom-all&quot;; &#125;&#125; 这样，无论是idea编译运行，还是jar包运行的方式，我们通过SpringFactory.getBean(UserService.class)获取到的就是 DefaultUserServiceImpl 对象。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://nonfou.github.io/tags/Spring/"}]},{"title":"Spring异步执行时同步上下文信息","slug":"Spring异步执行时同步上下文信息","date":"2022-01-05T12:57:16.000Z","updated":"2022-07-12T13:49:33.785Z","comments":true,"path":"2022/01/05/Spring异步执行时同步上下文信息/","link":"","permalink":"http://nonfou.github.io/2022/01/05/Spring%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E6%97%B6%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF/","excerpt":"","text":"Spring中启用异步 1234567@SpringBootApplication@EnableAsyncpublic class AsyncApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AsyncApplication.class, args); &#125;&#125; 12345678@Servicepublic class UserService &#123; @Async public void asyncUser() throws Exception &#123; // 同步用户信息 &#125;&#125; 123456789101112131415161718192021@Configurationpublic class ThreadPoolConfig &#123; @Bean(&quot;asyncExecutor&quot;) public Executor taskExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // 核心线程数（默认线程数） executor.setCorePoolSize(10); // 最大线程数 executor.setMaxPoolSize(20); // 缓冲队列数 executor.setQueueCapacity(200); // 允许线程空闲时间（单位：默认为秒） executor.setKeepAliveSeconds(60); // 线程池名前缀 executor.setThreadNamePrefix(&quot;taskExecutor-&quot;); // 线程池对拒绝任务的处理策略 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); return executor; &#125;&#125; 异步请求图例 同步当前线程信息到异步线程中 实现TaskDecorator 1234567891011121314public class ContextDecorator implements TaskDecorator &#123; @Override public Runnable decorate(Runnable runnable) &#123; RequestAttributes context = RequestContextHolder.currentRequestAttributes(); return () -&gt; &#123; try &#123; RequestContextHolder.setRequestAttributes(context); runnable.run(); &#125; finally &#123; RequestContextHolder.resetRequestAttributes(); &#125; &#125;; &#125;&#125; 1234567891011121314151617181920212223@Configurationpublic class ThreadPoolConfig &#123; @Bean(&quot;asyncExecutor&quot;) public Executor taskExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // 核心线程数（默认线程数） executor.setCorePoolSize(10); // 最大线程数 executor.setMaxPoolSize(20); // 缓冲队列数 executor.setQueueCapacity(200); // 允许线程空闲时间（单位：默认为秒） executor.setKeepAliveSeconds(60); // 线程池名前缀 executor.setThreadNamePrefix(&quot;taskExecutor-&quot;); // 线程池对拒绝任务的处理策略 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); // 增加 TaskDecorator 属性的配置 executor.setTaskDecorator(new ContextDecorator()); return executor; &#125;&#125; 这样异步线程就可以继承同步线程的上下文信息","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://nonfou.github.io/tags/Spring/"}]},{"title":"win10设置端口转发","slug":"win10设置端口转发","date":"2022-01-05T12:56:16.000Z","updated":"2022-07-12T13:49:43.209Z","comments":true,"path":"2022/01/05/win10设置端口转发/","link":"","permalink":"http://nonfou.github.io/2022/01/05/win10%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","excerpt":"","text":"Win10设置端口转发背景 在Win10 wsl系统（ip: 192.168.230.20）中启动了一个服务A，暴露出一个端口：3000，我在本机（ip：172.16.20.166）上访问，即：http://192.168.230.20:3000 没有问题，如果局域网中的其它电脑想要访问服务A，是访问不到的。 解决方案 如果局域网中的其它电脑需要访问本机wsl中启动的服务，则需要设置Win10的端口转发，将访问本机的端口转发到本机内部的wsl系统中 利用Nginx做端口转发 利用Win10配置端口转发 Win10配置端口转发管理员运行 配置端口转发 12# win10监听端口3000，转发到wsl（192.168.23.20）上的端口3000netsh interface portproxy add v4tov4 listenport=3000 connectport=3000 connectaddress=192.168.230.20 配置防火墙规则 12# 放行端口3000New-NetFirewallRule -DisplayName &quot;Allow Inbound TCP Port 3000&quot; -Direction Inbound -Action Allow -Protocol TCP -LocalPort 3000 命令参考 查看转发规则 1netsh interface portproxy show v4tov4 删除端口转发规则 1netsh interface portproxy delete v4tov4 listenport=3000 重置端口转发规则 1netsh interface portproxy reset 删除防火墙规则 1Remove-NetFirewallRule -DisplayName &quot;Allow Inbound TCP Port 3000&quot; 博客参考 Win10 与 WSL2 间的网络和文件互访 - LOGI","categories":[],"tags":[{"name":"Win","slug":"Win","permalink":"http://nonfou.github.io/tags/Win/"}]},{"title":"linux交互式脚本","slug":"linux交互式脚本","date":"2022-01-05T12:55:22.000Z","updated":"2022-07-12T13:48:29.108Z","comments":true,"path":"2022/01/05/linux交互式脚本/","link":"","permalink":"http://nonfou.github.io/2022/01/05/linux%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%84%9A%E6%9C%AC/","excerpt":"","text":"安装expect12# debian系sudo apt install expect Expect中常用的命令 spawn 启动新的进程 1spawn ssh root@192.168.5.23 expect 从进程接收字符串 12spawn ssh root@192.168.5.23expect &quot;*password:&quot; 12# 结束当前交互进程expect eof send 向进程发送字符串 1234spawn ssh root@192.168.5.23expect &quot;*password:&quot;# 添加回车符，执行当前输入send &quot;root\\r&quot; interact 结束自动执行，当前进程与用户交互 Example需求前端&#x2F;后端 项目本地打包部署到linux 脚本实现1234567891011121314151617181920212223242526272829303132#!/usr/bin/expectset user &quot;root&quot;set pass &quot;root&quot;set ip &quot;192.168.5.23&quot;# 停止服务spawn ssh $user@$ipexpect &quot;*password:&quot;send &quot;$pass\\r&quot;expect &quot;]#&quot; &#123; send &quot;cd /opt/stress-test/cloud/aims-stress-test/bin\\r&quot; &#125;expect &quot;]#&quot; &#123; send &quot;sh shutdown.sh\\r&quot; &#125;expect &quot;]#&quot; &#123; send &quot;cd /opt/stress-test/cloud\\r&quot;&#125;expect &quot;]#&quot; &#123; send &quot;rm -rf aims-stress-test\\r&quot;&#125;expect &quot;]#&quot; &#123; send &quot;rm -f aims-stress-test-external-linux-1.0.10-SNAPSHOT.tar.gz\\r&quot;&#125;expect &quot;]#&quot; &#123; send &quot;exit\\r&quot;&#125;expect eof# copyspawn scp /mnt/c/Users/Administrator/Desktop/tmp/aims-stress-test-external-linux-1.0.10-SNAPSHOT.tar.gz $user@$ip:/opt/stress-test/cloud/expect &quot;*password:&quot;send &quot;$pass\\r&quot;expect eof# 运行服务spawn ssh $user@$ipexpect &quot;*password:&quot;send &quot;$pass\\r&quot;expect &quot;]#&quot; &#123; send &quot;cd /opt/stress-test/cloud\\r&quot; &#125;expect &quot;]#&quot; &#123; send &quot;tar -xf aims-stress-test-external-linux-1.0.10-SNAPSHOT.tar.gz\\r&quot; &#125;expect &quot;]#&quot; &#123; send &quot;cd /opt/stress-test/cloud/aims-stress-test/bin\\r&quot; &#125;expect &quot;]#&quot; &#123; send &quot;sh startup.sh\\r&quot; &#125;interact","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://nonfou.github.io/tags/Linux/"}]},{"title":"oracle常用命令","slug":"oracle常用命令","date":"2022-01-05T12:53:46.000Z","updated":"2022-07-12T13:49:07.269Z","comments":true,"path":"2022/01/05/oracle常用命令/","link":"","permalink":"http://nonfou.github.io/2022/01/05/oracle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查询用户1select * from dba_users; 查询表空间1select * from Dba_Tablespaces; 删除用户1drop user gmzc_aim cascade ; 查询文件夹1select * from SYS.ALL_DIRECTORIES; 创建表空间1create tablespace GMZC_AIM datafile &#x27;/home/oracle/app/oracle/oradata/orcl55/gmzc_aim.dbf&#x27; size 3G autoextend on next 1024M maxsize 15G extent management local; 创建用户12345678910111213create user gmzc_aim identified by gmzc_aim default tablespace GMZC_AIM;grant dba to gmzc_aim;grant connect,resource to gmzc_aim;grant select any table to gmzc_aim;grant delete any table to gmzc_aim;grant update any table to gmzc_aim;grant insert any table to gmzc_aim; 断掉用户的数据库连接12select username,sid,serial#,paddr from v$session where username=&#x27;GMZC_AIM&#x27;;alter system kill session &#x27;130,9&#x27;; 导入1impdp gmzc_aim/gmzc_aim@orcl55 DIRECTORY=DATA_PUMP_DIR DUMPFILE=gmzc_aim_2021_12_16.dmp SCHEMAS=GMZC_AIM remap_tablespace=SIRM2:GMZC_AIM 导出12expdp 用户名/密码@数据库实例名 directory=导出目录 dumpfile=导出的文件名.dmp logfile=导出的日志名.log--例：expdp GISDATA/GISDATA@LOCALHOST/orcl directory=dmp dumpfile=GISDATA20200921.dmp logfile=GISDATA20200921.log","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://nonfou.github.io/tags/Oracle/"}]},{"title":"centos笔记","slug":"centos笔记","date":"2022-01-05T12:50:23.000Z","updated":"2022-07-12T13:48:11.844Z","comments":true,"path":"2022/01/05/centos笔记/","link":"","permalink":"http://nonfou.github.io/2022/01/05/centos%E7%AC%94%E8%AE%B0/","excerpt":"centos设置固定ip","text":"centos设置固定ip 配置文件一般在 &#x2F;etc&#x2F;sysconfig&#x2F; 下 1234567891011121314151617181920TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=eth0UUID=472c3283-9c65-4d3b-a97d-6c69f9fc0561DEVICE=eth0ONBOOT=yesIPADDR=172.16.20.16GATEWAY=172.16.20.1NETMASK=255.255.255.0DNS1=172.16.20.1DNS2=114.114.114.114 查看防火墙某个端口是否开放1firewall-cmd --query-port=3306/tcp 开放防火墙端口33061firewall-cmd --zone=public --add-port=3306/tcp --permanent 注意：开放端口后要重启防火墙生效 重启防火墙1systemctl restart firewalld 关闭防火墙端口1firewall-cmd --remove-port=3306/tcp --permanent 查看防火墙状态1systemctl status firewalld 关闭防火墙1systemctl stop firewalld 打开防火墙1systemctl start firewalld 开放一段端口1firewall-cmd --zone=public --add-port=40000-45000/tcp --permanent 查看开放的端口列表1firewall-cmd --zone=public --list-ports 查看被监听(Listen)的端口1netstat -lntp 检查端口被哪个进程占用1netstat -lnp|grep 3306 问题记录nginx 启动端口限制问题123semanage port -a -t http_port_t -p tcp 88semanage port -l | grep 88 nginx出现错误(Permission denied) while connecting to upstream的问题1setsebool -P httpd_can_network_connect 1","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://nonfou.github.io/tags/Linux/"}]},{"title":"Nginx转发问题","slug":"Nginx转发问题","date":"2021-08-28T10:41:18.000Z","updated":"2022-07-12T13:48:49.169Z","comments":true,"path":"2021/08/28/Nginx转发问题/","link":"","permalink":"http://nonfou.github.io/2021/08/28/Nginx%E8%BD%AC%E5%8F%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"Nginx转发接口异常，随机出现404&#x2F;200问题前端nginx部署，后端单体Spring Boot服务 重新部署后，当访问页面时，新添加的模块里的接口有时出现404，有时正常返回200。 思考之前遇到过一个差不多的问题，k8s部署应用时，应用存在多实例的情况，而其中一个实例是比较久的代码打包的，访问接口时就出现有时报错有时正常的情况 graph TB A[请求] --> B{\"Nginx\"} B -->C[\"应用实例A\"] B -->D[\"应用实例B\"] 新添加的接口只存在应用实例B中，当nginx请求转发到应用实例B中，接口正常返回，当nginx请求转发到应用实例A中，接口表现异常 由此，我想到应该是Nginx转发出现了问题。 解决先查看日志 nginx访问日志出现了502 552的情况 nginx错误日志 1connect() failed (111: Connection refused) while connecting to upstream 应用是单体应用部署，不会是上次遇到的情况。 搜索了一堆东西…… nginx 交替出现404 和200的问题 查看nginx进程 1ps -ef | grep nginx 果然存在多个master进程，保留一个就好了。 graph TB A[请求] --> B{\"Nginx服务器\"} B -->C[\"Nginx Master A\"] B -->D[\"Nginx Master B\"] C -->E[\"应用实例\"] D -->E 当接口通过master A转发时，找不到匹配的url，表现在页面就是404 当接口通过master B转发时，正确匹配到后端url，表现就是200","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://nonfou.github.io/tags/Nginx/"}]},{"title":"software","slug":"software","date":"2021-08-14T16:08:26.000Z","updated":"2022-06-25T15:08:06.863Z","comments":true,"path":"2021/08/15/software/","link":"","permalink":"http://nonfou.github.io/2021/08/15/software/","excerpt":"","text":"软件 Typora markdown编辑器 vscode 文本编辑器 Docker http://get.daocloud.io/#install-docker 1curl -sSL https://get.daocloud.io/docker | sh docker compose 1sudo aptitude install docker-compose 构建mysql 12345678910# Mysql根目录mkdir -p ~/Programs/Mysql# 数据目录mkdir -p ~/Programs/Mysql/data# 配置目录mkdir -p ~/Programs/Mysql/conf# 初始化脚本目录mkdir -p ~/Porgrams/Mysql/initcd ~/Programs/Mysql touch docker-compose.yaml 命令行翻译 1234sudo aptitude install npm# 配置淘宝镜像npm config set registry https://registry.npm.taobao.orgnpm install terminal-translate -g 问题记录 将当前用户加入docker组 ERROR: Couldn’t connect to Docker daemon at http+docker:&#x2F;&#x2F;localunixsocket - is it running?If it’s at a non-standard location, specify the URL with the DOCKER_HOST environment variable. 12345sudo gpasswd -a $&#123;USER&#125; docker#将普通用户username加入到docker组sudo gpasswd -a username docker#更新docker组newgrp docker","categories":[],"tags":[]},{"title":"NoSuchMethodError","slug":"NoSuchMethodError","date":"2021-08-12T10:41:18.000Z","updated":"2022-07-12T13:48:57.141Z","comments":true,"path":"2021/08/12/NoSuchMethodError/","link":"","permalink":"http://nonfou.github.io/2021/08/12/NoSuchMethodError/","excerpt":"","text":"NoSuchMethodError大多数情况下是因为jar包冲突 以找不到该方法com.nonfou.test.util.TimeUtil.getYear()为例 jar包版本A中不存在此方法，版本为1.5.6 jar包版本B中存在此方法，版本为2.6.3 现在系统中同时引用这两个jar包（名称相同，版本不同），此时如果你的业务依赖TimeUtil.getYear()方法，实际运行时引用了版本A，导致出现错误，这时就需要把版本A在你的环境依赖中去掉 查看运行时，TimeUtil类引用自哪个jar包 利用工具ARTHAS[快速入门 — Arthas 3.5.3 文档 (aliyun.com)] 分析pom依赖结构，去掉步骤1中获取的jar包版本 12# 查找artifactId为common_uitl的依赖关系mvn dependency:tree -Dincludes=:common_util 通过步骤2可以找到哪些jar包引用了jar包版本A，在pom中去掉即可","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://nonfou.github.io/tags/Java/"}]}],"categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://nonfou.github.io/tags/Linux/"},{"name":"Oracle","slug":"Oracle","permalink":"http://nonfou.github.io/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"http://nonfou.github.io/tags/Java/"},{"name":"Mock","slug":"Mock","permalink":"http://nonfou.github.io/tags/Mock/"},{"name":"Spring","slug":"Spring","permalink":"http://nonfou.github.io/tags/Spring/"},{"name":"Win","slug":"Win","permalink":"http://nonfou.github.io/tags/Win/"},{"name":"Nginx","slug":"Nginx","permalink":"http://nonfou.github.io/tags/Nginx/"}]}