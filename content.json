{"meta":{"title":"徐冲的草稿本","subtitle":"","description":"","author":"Chong Xu","url":"http://nonfou.github.io","root":"/"},"pages":[{"title":"about","date":"2022-05-24T13:43:28.000Z","updated":"2022-05-24T13:44:14.549Z","comments":true,"path":"about/index.html","permalink":"http://nonfou.github.io/about/index.html","excerpt":"","text":"where there is a will, there is a way."},{"title":"category","date":"2022-05-24T13:38:36.000Z","updated":"2022-05-24T13:38:54.217Z","comments":true,"path":"category/index.html","permalink":"http://nonfou.github.io/category/index.html","excerpt":"","text":""},{"title":"tag","date":"2022-05-24T13:37:22.000Z","updated":"2022-05-24T13:38:24.198Z","comments":true,"path":"tag/index.html","permalink":"http://nonfou.github.io/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"Mock后端接口","slug":"Mock后端接口","date":"2022-07-07T15:01:52.000Z","updated":"2022-07-25T15:10:24.036Z","comments":true,"path":"2022/07/07/Mock后端接口/","link":"","permalink":"http://nonfou.github.io/2022/07/07/Mock%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"场景后端对于接口数据的Mock 依赖的子服务 Feign&#x2F;Dubbo等rpc请求 第三方接口,天眼查&#x2F;启信宝 方案参考两个开源项目实现 模拟mock.js生成数据，简称 项目1 基于Agent实现接口mock，简称 项目2 项目1可以对mock数据有很好的支持，项目2基于Agent，无侵入的完成接口的代理。由此对两个项目进行了整合。 实践代理的方法针对你想Mock的所有接口，找寻一个共有的前置方法。 Dubbo调用 org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke Feign 调用 feign.SynchronousMethodHandler.invoke Aop环绕通知拦截 org.springframework.aop.aspectj.AspectJAroundAdvice 匹配Mock规则项目2中是通过以类名称#方法名称作为名称，以文件的形式去定义Mock的内容。 为了结合项目1去使用，我们在原有Mock内容的基础上增加了Mock类的路径 1234&#123; &quot;f_mock_data&quot;: &quot;&quot;, &quot;class_name&quot;: &quot;com.nonfou.example.dto.BasicInfoDTO&quot;&#125; 然后使用项目1mock出不同的数据。 1new AnnotationMockContext().mock(Class.forName(&quot;$&#123;类路径&#125;&quot;)); 问题 思路的打通 理解使用Agent，明白项目2设计思路，如何结合项目1使用。 找到代理方法 针对我想Mock的接口，通过给所有要代理的接口添加了注解，然后使用Aop去增强，这样所有的接口都会经过Aop的代理方法。 NoClassDefFoundError SpringBoot中agent代理aop方法，实现类隔离加载","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://nonfou.github.io/tags/Java/"},{"name":"Mock","slug":"Mock","permalink":"http://nonfou.github.io/tags/Mock/"}]},{"title":"插入clob到oracle","slug":"插入clob到oracle","date":"2022-05-27T13:10:01.000Z","updated":"2022-10-27T13:13:27.803Z","comments":true,"path":"2022/05/27/插入clob到oracle/","link":"","permalink":"http://nonfou.github.io/2022/05/27/%E6%8F%92%E5%85%A5clob%E5%88%B0oracle/","excerpt":"","text":"背景转移两个库中的一个表数据，此表包含CLOB类型的字段 思考 dmp只导出导入一个表的数据 groovy脚本 groovy脚本插入CLOB到oracle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class CopyData &#123; private static Sql targetOracle = Sql.newInstance( &quot;jdbc:oracle:thin:@182.16.45.23:1521:orcl&quot;, &quot;aaa123&quot;, &quot;aaa123&quot;, &quot;oracle.jdbc.OracleDriver&quot; ) private static Sql sourceOracle = Sql.newInstance( &quot;jdbc:oracle:thin:@196.15.23.45:1521:orcl&quot;, &quot;bbb123&quot;, &quot;bbb123&quot;, &quot;oracle.jdbc.OracleDriver&quot; ) static void main(String[] args) &#123; List&lt;News&gt; list = originalData(); insertData(list); &#125; static void insertData(List&lt;News&gt; list) &#123; String sql = &quot;&quot;&quot;insert into news(id, type, content, title)values(?, ?, ?, ?)&quot;&quot;&quot; PreparedStatement preparedStatement = targetOracle.getConnection().prepareStatement(sql) ListUtil.partition(news, 1000).each &#123; it.each &#123;newsData -&gt; preparedStatement.setLong(1, newsData.id as Long) preparedStatement.setObject(2, newsData.type) preparedStatement.setCharacterStream(3, new StringReader(newsData.content.getCharacterStream().text)) preparedStatement.setObject(4, newsData.title) preparedStatement.addBatch() &#125; preparedStatement.executeBatch() &#125; &#125; static List&lt;News&gt; originalData() &#123; def result = [] def sql = &quot;&quot;&quot; select * from news where ROWNUM &lt; 100000&quot;&quot;&quot; sourceOracle.eachRow(sql) &#123; result.push(new News( id: it.id, type: it.type, title: it.title, content: it.content )) &#125; return result &#125; static class News &#123; String id Integer type String title Clob content &#125; &#125; 参考链接Insert CLOB into Oracle database","categories":[],"tags":[{"name":"Groovy","slug":"Groovy","permalink":"http://nonfou.github.io/tags/Groovy/"}]},{"title":"多线程执行计算","slug":"多线程执行计算","date":"2022-05-27T13:08:02.000Z","updated":"2022-10-27T13:13:34.376Z","comments":true,"path":"2022/05/27/多线程执行计算/","link":"","permalink":"http://nonfou.github.io/2022/05/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E7%AE%97/","excerpt":"","text":"背景需要查询的数据较多，与数据库交互比较频繁；算法比较复杂，执行速度较慢。 思考 先全部查询出计算所需要的全部数据 多线程执行计算任务 聚合计算结果 方案123456789101112131415161718192021222324252627282930List&lt;CompletableFuture&lt;List&lt;ResultValue&gt;&gt;&gt; futureResults = new ArrayList&lt;&gt;();List&lt;ResultValue&gt; resultValues = new ArrayList&lt;&gt;();for (OriginalData originalData : originalDatas) &#123; // 使用异步任务，开启多线程计算 CompletableFuture&lt;List&lt;ResultValue&gt;&gt; sceneResults = CompletableFuture.supplyAsync( // 执行计算 () -&gt; executeCalculate(originalData); , SpringFactory.getBean(Executor.class) ); futureResults.add(sceneResults);&#125;// 主线程会等待所有子线程执行结束try &#123; CompletableFuture.allOf(futureResults.toArray(new CompletableFuture[0])).join();&#125; catch (Exception e) &#123; log.error(&quot;计算任务失败&quot;, e) throw new RuntimeException(e.getCause().getMessage());&#125;// 聚合计算结果for (CompletableFuture&lt;List&lt;ResultValue&gt;&gt; future : futureResults) &#123; future.whenComplete((resultList, throwable) -&gt; &#123; if (CollUtil.isNotEmpty(resultList)) &#123; resultValues.addAll(resultList); &#125; &#125;);&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://nonfou.github.io/tags/Java/"}]},{"title":"Spring异步执行时同步上下文信息","slug":"Spring异步执行时同步上下文信息","date":"2022-01-05T12:57:16.000Z","updated":"2022-07-12T13:49:33.785Z","comments":true,"path":"2022/01/05/Spring异步执行时同步上下文信息/","link":"","permalink":"http://nonfou.github.io/2022/01/05/Spring%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E6%97%B6%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF/","excerpt":"","text":"Spring中启用异步 1234567@SpringBootApplication@EnableAsyncpublic class AsyncApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AsyncApplication.class, args); &#125;&#125; 12345678@Servicepublic class UserService &#123; @Async public void asyncUser() throws Exception &#123; // 同步用户信息 &#125;&#125; 123456789101112131415161718192021@Configurationpublic class ThreadPoolConfig &#123; @Bean(&quot;asyncExecutor&quot;) public Executor taskExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // 核心线程数（默认线程数） executor.setCorePoolSize(10); // 最大线程数 executor.setMaxPoolSize(20); // 缓冲队列数 executor.setQueueCapacity(200); // 允许线程空闲时间（单位：默认为秒） executor.setKeepAliveSeconds(60); // 线程池名前缀 executor.setThreadNamePrefix(&quot;taskExecutor-&quot;); // 线程池对拒绝任务的处理策略 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); return executor; &#125;&#125; 异步请求图例 同步当前线程信息到异步线程中 实现TaskDecorator 1234567891011121314public class ContextDecorator implements TaskDecorator &#123; @Override public Runnable decorate(Runnable runnable) &#123; RequestAttributes context = RequestContextHolder.currentRequestAttributes(); return () -&gt; &#123; try &#123; RequestContextHolder.setRequestAttributes(context); runnable.run(); &#125; finally &#123; RequestContextHolder.resetRequestAttributes(); &#125; &#125;; &#125;&#125; 1234567891011121314151617181920212223@Configurationpublic class ThreadPoolConfig &#123; @Bean(&quot;asyncExecutor&quot;) public Executor taskExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // 核心线程数（默认线程数） executor.setCorePoolSize(10); // 最大线程数 executor.setMaxPoolSize(20); // 缓冲队列数 executor.setQueueCapacity(200); // 允许线程空闲时间（单位：默认为秒） executor.setKeepAliveSeconds(60); // 线程池名前缀 executor.setThreadNamePrefix(&quot;taskExecutor-&quot;); // 线程池对拒绝任务的处理策略 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); // 增加 TaskDecorator 属性的配置 executor.setTaskDecorator(new ContextDecorator()); return executor; &#125;&#125; 这样异步线程就可以继承同步线程的上下文信息","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://nonfou.github.io/tags/Spring/"}]},{"title":"win10设置端口转发","slug":"win10设置端口转发","date":"2022-01-05T12:56:16.000Z","updated":"2022-07-26T14:29:50.360Z","comments":true,"path":"2022/01/05/win10设置端口转发/","link":"","permalink":"http://nonfou.github.io/2022/01/05/win10%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","excerpt":"","text":"Win10设置端口转发背景 在Win10 wsl系统（ip: 192.168.230.20）中启动了一个服务A，暴露出一个端口：3000，我在本机（ip：172.18.20.166）上访问，即：http://192.168.230.20:3000 没有问题，如果局域网中的其它电脑想要访问服务A，是访问不到的。 解决方案 如果局域网中的其它电脑需要访问本机wsl中启动的服务，则需要设置Win10的端口转发，将访问本机的端口转发到本机内部的wsl系统中 利用Nginx做端口转发 利用Win10配置端口转发 Win10配置端口转发管理员运行 配置端口转发 12# win10监听端口3000，转发到wsl（192.168.23.20）上的端口3000netsh interface portproxy add v4tov4 listenport=3000 connectport=3000 connectaddress=192.168.230.20 配置防火墙规则 12# 放行端口3000New-NetFirewallRule -DisplayName &quot;Allow Inbound TCP Port 3000&quot; -Direction Inbound -Action Allow -Protocol TCP -LocalPort 3000 命令参考 查看转发规则 1netsh interface portproxy show v4tov4 删除端口转发规则 1netsh interface portproxy delete v4tov4 listenport=3000 重置端口转发规则 1netsh interface portproxy reset 删除防火墙规则 1Remove-NetFirewallRule -DisplayName &quot;Allow Inbound TCP Port 3000&quot; 博客参考 Win10 与 WSL2 间的网络和文件互访 - LOGI","categories":[],"tags":[{"name":"Win","slug":"Win","permalink":"http://nonfou.github.io/tags/Win/"}]},{"title":"linux交互式脚本","slug":"linux交互式脚本","date":"2022-01-05T12:55:22.000Z","updated":"2022-07-26T14:26:24.914Z","comments":true,"path":"2022/01/05/linux交互式脚本/","link":"","permalink":"http://nonfou.github.io/2022/01/05/linux%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%84%9A%E6%9C%AC/","excerpt":"","text":"安装expect12# debian系sudo apt install expect Expect中常用的命令 spawn 启动新的进程 1spawn ssh root@192.168.5.23 expect 从进程接收字符串 12spawn ssh root@192.168.5.23expect &quot;*password:&quot; 12# 结束当前交互进程expect eof send 向进程发送字符串 1234spawn ssh root@192.168.5.23expect &quot;*password:&quot;# 添加回车符，执行当前输入send &quot;root\\r&quot; interact 结束自动执行，当前进程与用户交互 Example需求前端&#x2F;后端 项目本地打包部署到linux 脚本实现1234567891011121314151617181920212223242526#!/usr/bin/expectset user &quot;root&quot;set pass &quot;root&quot;set ip &quot;192.168.5.23&quot;# 停止服务spawn ssh $user@$ipexpect &quot;*password:&quot;send &quot;$pass\\r&quot;expect &quot;]#&quot; &#123; send &quot;cd /opt/project1/bin\\r&quot; &#125;expect &quot;]#&quot; &#123; send &quot;exit\\r&quot;&#125;expect eof# copyspawn scp [jar路径] $user@$ip:/opt/project/cloud/expect &quot;*password:&quot;send &quot;$pass\\r&quot;expect eof# 运行服务spawn ssh $user@$ipexpect &quot;*password:&quot;send &quot;$pass\\r&quot;expect &quot;]#&quot; &#123; send &quot;cd /opt/project/cloud\\r&quot; &#125;expect &quot;]#&quot; &#123; send &quot;sh startup.sh\\r&quot; &#125;interact","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://nonfou.github.io/tags/Linux/"}]},{"title":"oracle常用命令","slug":"oracle常用命令","date":"2022-01-05T12:53:46.000Z","updated":"2022-07-26T14:29:05.536Z","comments":true,"path":"2022/01/05/oracle常用命令/","link":"","permalink":"http://nonfou.github.io/2022/01/05/oracle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查询用户1select * from dba_users; 查询表空间1select * from Dba_Tablespaces; 删除用户1drop user gmqqqq cascade ; 查询文件夹1select * from SYS.ALL_DIRECTORIES; 创建表空间1create tablespace gfaa datafile &#x27;/home/oracle/app/oracle/oradata/orcl55/gfaa.dbf&#x27; size 3G autoextend on next 1024M maxsize 15G extent management local; 创建用户12345678910111213create user aaa identified by aaa default tablespace gfaa;grant dba to aaa;grant connect,resource to aaa;grant select any table to aaa;grant delete any table to aaa;grant update any table to aaa;grant insert any table to aaa; 断掉用户的数据库连接12select username,sid,serial#,paddr from v$session where username=&#x27;aaa&#x27;;alter system kill session &#x27;130,9&#x27;; 导入1impdp bbb/bbb@orcl55 DIRECTORY=DATA_PUMP_DIR DUMPFILE=20120115.dmp SCHEMAS=aaa remap_tablespace=bbb:gggg 导出12expdp 用户名/密码@数据库实例名 directory=导出目录 dumpfile=导出的文件名.dmp logfile=导出的日志名.log--例：expdp GISDATA/GISDATA@LOCALHOST/orcl directory=dmp dumpfile=GISDATA20200921.dmp logfile=GISDATA20200921.log","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://nonfou.github.io/tags/Oracle/"}]},{"title":"centos笔记","slug":"centos笔记","date":"2022-01-05T12:50:23.000Z","updated":"2022-07-26T14:24:34.304Z","comments":true,"path":"2022/01/05/centos笔记/","link":"","permalink":"http://nonfou.github.io/2022/01/05/centos%E7%AC%94%E8%AE%B0/","excerpt":"centos设置固定ip","text":"centos设置固定ip 配置文件一般在 &#x2F;etc&#x2F;sysconfig&#x2F; 下 1234567891011121314151617181920TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=eth0UUID=472c3283-9c65-4d3b-a97d-6c69f9fc0541DEVICE=eth0ONBOOT=yesIPADDR=GATEWAY=NETMASK=DNS1=DNS2= 查看防火墙某个端口是否开放1firewall-cmd --query-port=3306/tcp 开放防火墙端口33061firewall-cmd --zone=public --add-port=3306/tcp --permanent 注意：开放端口后要重启防火墙生效 重启防火墙1systemctl restart firewalld 关闭防火墙端口1firewall-cmd --remove-port=3306/tcp --permanent 查看防火墙状态1systemctl status firewalld 关闭防火墙1systemctl stop firewalld 打开防火墙1systemctl start firewalld 开放一段端口1firewall-cmd --zone=public --add-port=40000-45000/tcp --permanent 查看开放的端口列表1firewall-cmd --zone=public --list-ports 查看被监听(Listen)的端口1netstat -lntp 检查端口被哪个进程占用1netstat -lnp|grep 3306 问题记录nginx 启动端口限制问题123semanage port -a -t http_port_t -p tcp 88semanage port -l | grep 88 nginx出现错误(Permission denied) while connecting to upstream的问题1setsebool -P httpd_can_network_connect 1","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://nonfou.github.io/tags/Linux/"}]},{"title":"Nginx转发问题","slug":"Nginx转发问题","date":"2021-08-28T10:41:18.000Z","updated":"2022-07-12T13:48:49.169Z","comments":true,"path":"2021/08/28/Nginx转发问题/","link":"","permalink":"http://nonfou.github.io/2021/08/28/Nginx%E8%BD%AC%E5%8F%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"Nginx转发接口异常，随机出现404&#x2F;200问题前端nginx部署，后端单体Spring Boot服务 重新部署后，当访问页面时，新添加的模块里的接口有时出现404，有时正常返回200。 思考之前遇到过一个差不多的问题，k8s部署应用时，应用存在多实例的情况，而其中一个实例是比较久的代码打包的，访问接口时就出现有时报错有时正常的情况 graph TB A[请求] --> B{\"Nginx\"} B -->C[\"应用实例A\"] B -->D[\"应用实例B\"] 新添加的接口只存在应用实例B中，当nginx请求转发到应用实例B中，接口正常返回，当nginx请求转发到应用实例A中，接口表现异常 由此，我想到应该是Nginx转发出现了问题。 解决先查看日志 nginx访问日志出现了502 552的情况 nginx错误日志 1connect() failed (111: Connection refused) while connecting to upstream 应用是单体应用部署，不会是上次遇到的情况。 搜索了一堆东西…… nginx 交替出现404 和200的问题 查看nginx进程 1ps -ef | grep nginx 果然存在多个master进程，保留一个就好了。 graph TB A[请求] --> B{\"Nginx服务器\"} B -->C[\"Nginx Master A\"] B -->D[\"Nginx Master B\"] C -->E[\"应用实例\"] D -->E 当接口通过master A转发时，找不到匹配的url，表现在页面就是404 当接口通过master B转发时，正确匹配到后端url，表现就是200","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://nonfou.github.io/tags/Nginx/"}]},{"title":"Linux使用小结","slug":"Linux使用小结","date":"2021-08-14T16:08:26.000Z","updated":"2022-07-12T14:17:16.284Z","comments":true,"path":"2021/08/15/Linux使用小结/","link":"","permalink":"http://nonfou.github.io/2021/08/15/Linux%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/","excerpt":"整理一些Linux(Debian系)软件和问题","text":"整理一些Linux(Debian系)软件和问题 软件Docker http://get.daocloud.io/#install-docker 1curl -sSL https://get.daocloud.io/docker | sh docker compose 1sudo aptitude install docker-compose 构建mysql 12345678910# Mysql根目录mkdir -p ~/Programs/Mysql# 数据目录mkdir -p ~/Programs/Mysql/data# 配置目录mkdir -p ~/Programs/Mysql/conf# 初始化脚本目录mkdir -p ~/Porgrams/Mysql/initcd ~/Programs/Mysql docker-compose.yaml 命令行翻译1234sudo aptitude install npm# 配置淘宝镜像npm config set registry https://registry.npm.taobao.orgnpm install terminal-translate -g 截图Flameshot 1sudo apt install flameshot 启动器Albert 官网 输入法Rime 1sudo apt install fcitx5-rime 问题将当前用户加入docker组12ERROR: Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running?If it’s at a non-standard location, specify the URL with the DOCKER_HOST environment variable. 12345sudo gpasswd -a $&#123;USER&#125; docker#将普通用户username加入到docker组sudo gpasswd -a username docker#更新docker组newgrp docker grub启动界面乱码 查看grub下的字体 12ls /boot/grub/fonts/ 修改unicode字体 1vim /etc/default/grub.d/60_mint-theme.cfg","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://nonfou.github.io/tags/Linux/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://nonfou.github.io/tags/Java/"},{"name":"Mock","slug":"Mock","permalink":"http://nonfou.github.io/tags/Mock/"},{"name":"Groovy","slug":"Groovy","permalink":"http://nonfou.github.io/tags/Groovy/"},{"name":"Spring","slug":"Spring","permalink":"http://nonfou.github.io/tags/Spring/"},{"name":"Win","slug":"Win","permalink":"http://nonfou.github.io/tags/Win/"},{"name":"Linux","slug":"Linux","permalink":"http://nonfou.github.io/tags/Linux/"},{"name":"Oracle","slug":"Oracle","permalink":"http://nonfou.github.io/tags/Oracle/"},{"name":"Nginx","slug":"Nginx","permalink":"http://nonfou.github.io/tags/Nginx/"}]}